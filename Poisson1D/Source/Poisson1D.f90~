Module Poisson1DMod
  Use tools
  Use domainMod
  Use element1DMod
  Use GaussLegendreFEM
  Use sparseMod
  Use Print_All
  Implicit none
  Private
  Public :: Poisson1DType

  Type Poisson1DType
     Type(DomainType) :: domain
     Integer :: nGauss
     Procedure(fDefault), pointer, nopass :: kCoef
     Procedure(fDefault), pointer, nopass :: source
     Type(sparseType) :: K
     Real(dp), Dimension(:), Allocatable :: phi
     Real(dp), Dimension(:), Allocatable :: rhs
     Real(dp), Dimension(:), Allocatable :: flux
     Integer, Dimension(:), Allocatable :: DirichletNode, NeumannNode
     Real(dp), Dimension(:), Allocatable :: DirichletValue, NeumannValue
   Contains
     Procedure, Public :: init
     Procedure, Public :: update
     Procedure, Public :: solve
     Procedure, Private :: computeK
     Procedure, Private :: computeRHS
     Procedure, Private :: boundaryConditions
     Procedure, Public :: computeFlux
     Procedure, Private :: valueJacobianGaussPoints
     Procedure, Private :: valueJacobianGaussPointPlusQ
     Procedure, Private :: valueJacobianNodePoints
  End type Poisson1DType
  
  Real(dp), Dimension(:,:,:), Allocatable :: shapeFuncMat, derivShapeFuncMat
  Real(dp), Dimension(:), Allocatable :: QVect, kVect
  Real(dp) :: Kij, fi
  Integer :: i, j, iElem, ip, jp
  
Contains

  Real(dp) Function fDefault(i,x)
    Implicit none
    Integer, Intent(In) :: i
    Real(dp), Intent(In) :: x
  End Function fDefault

  Subroutine init(this)
    Implicit none
    Class(Poisson1DType), Intent(InOut) :: this
    Call setGauss(this%nGauss)

    Allocate(shapeFuncMat(3,4,this%nGauss))
    Allocate(derivShapeFuncMat(3,4,this%nGauss))

    Call valueGauss(lineardN, derivShapeFuncMat(1,1:2,1:this%nGauss))
    Call valueGauss(cuadraticdN, derivShapeFuncMat(2,1:3,1:this%nGauss))
    Call valueGauss(cubicdN, derivShapeFuncMat(3,1:4,1:this%nGauss))
    Call valueGauss(linearN, shapeFuncMat(1,1:2,1:this%nGauss))
    Call valueGauss(cuadraticN, shapeFuncMat(2,1:3,1:this%nGauss))
    Call valueGauss(cubicN, shapeFuncMat(3,1:4,1:this%nGauss))
    Do iElem = 1, this%domain%nElem
       Call this%valueJacobianGaussPoints
    End Do
  End Subroutine init

  Subroutine update(this)
    Implicit none
    Class(Poisson1DType), Intent(InOut) :: this
    Call setGauss(this%nGauss)
    If(Allocated(shapeFuncMat)) then
       Deallocate(shapeFuncMat)
       Deallocate(derivShapeFuncMat)
    End If
    
    Allocate(shapeFuncMat(3,4,this%nGauss))
    Allocate(derivShapeFuncMat(3,4,this%nGauss))

    Call valueGauss(lineardN, derivShapeFuncMat(1,1:2,1:this%nGauss))
    Call valueGauss(cuadraticdN, derivShapeFuncMat(2,1:3,1:this%nGauss))
    Call valueGauss(cubicdN, derivShapeFuncMat(3,1:4,1:this%nGauss))
    Call valueGauss(linearN, shapeFuncMat(1,1:2,1:this%nGauss))
    Call valueGauss(cuadraticN, shapeFuncMat(2,1:3,1:this%nGauss))
    Call valueGauss(cubicN, shapeFuncMat(3,1:4,1:this%nGauss))
    Do iElem = 1, this%domain%nElem
       Deallocate(this%domain%element(iElem)%jacobian)
       Call this%valueJacobianGaussPoints
    End Do
  End Subroutine update

  Subroutine solve(this)
    Use GMRES
    Implicit none
    Class(Poisson1DType) :: this
    Integer, parameter :: ITR_MAX = 1000
    Real(dp), parameter :: TOL_ABS = 1d-15
    Call this%computeK
    Call this%computeRHS
    Allocate(this%phi(this%domain%nNodes))
    Call this%boundaryConditions
    this%phi = 0.d0
!!$    Do i = 1, this%domain%nNodes
!!$       Do j = this%K%AI(i), this%K%AI(i+1)-1
!!$          Print'(A,I0,A,I0,A,E10.4)', 'k(', i, ',', this%K%AJ(j), ') = ', this%K%A(j)
!!$       End Do
!!$    End Do
!!$    Do i = 1, this%domain%nNodes
!!$       Print'(A,I0,A,E10.4)', 'f(',i,') = ', this%rhs(i)
!!$    End Do
    Call pmgmres_ilu_cr(               &
           n = this%domain%nNodes      &
         , nz_num = size(this%K%A)     &
         , ia = this%K%AI              &
         , ja = this%K%AJ              &
         , a = this%K%A                &
         , x = this%phi                &
         , rhs = this%rhs              &
         , itr_max = ITR_MAX           &
         , mr = 500                    &
         , tol_abs = TOL_ABS           &
         , tol_rel = 1d-15            )
    !Call problem%computeFlux
  End Subroutine solve

  Subroutine valueJacobianGaussPoints(this)
    Implicit none
    Class(Poisson1DType), Intent(InOut) :: this
    Integer :: nNodes
    Allocate(this%domain%element(iElem)%jacobian(this%nGauss))
    this%domain%element(iElem)%jacobian(:) = 0
    nNodes = this%domain%element(iElem)%nNodes
    Do i = 1, nNodes
       this%domain%element(iElem)%jacobian(:) = this%domain%element(iElem)%jacobian(:) &
            + derivShapeFuncMat(nNodes-1, i, :)*this%domain%x(this%domain%element(iElem)%node(i))
    End Do
  End Subroutine valueJacobianGaussPoints

  Subroutine valueJacobianNodePoints(this)
    Implicit none
    Class(Poisson1DType), Intent(InOut) :: this
    Real(dp), Dimension(4) :: u
    Real(dp), Dimension(4) :: dN
    Deallocate(this%domain%element(iElem)%jacobian)
    Allocate(this%domain%element(iElem)%jacobian(this%domain%element(iElem)%nNodes))
    this%domain%element(iElem)%jacobian(:) = 0
    u(1) = -1.d0
    u(4) = 1.d0
    Do i = 1, this%domain%element(iElem)%nNodes
       u(2) = -1.d0 +  2.d0/(this%domain%element(iElem)%nNodes-1)
       u(3) = -1.d0 + 2*2.d0/(this%domain%element(iElem)%nNodes-1)
       dN = this%domain%element(iElem)%dN(u(i),this%domain%element(iElem)%nNodes)
       Do j = 1, this%domain%element(iElem)%nNodes
          this%domain%element(iElem)%jacobian(i) = this%domain%element(iElem)%jacobian(i) &
               + dN(j)*this%domain%x(this%domain%element(iElem)%node(j))
       End Do
    End Do
  End Subroutine valueJacobianNodePoints

  Subroutine valueJacobianGaussPointPlusQ(this)
    Implicit none
    Class(Poisson1DType), Intent(InOut) :: this
    Integer :: nNodes
    this%domain%element(iElem)%jacobian(:) = 0
    nNodes = this%domain%element(iElem)%nNodes
    Do i = 1, nNodes
       this%domain%element(iElem)%jacobian(:) = this%domain%element(iElem)%jacobian(:) &
            + derivShapeFuncMat(nNodes-1, i, :) &
            * this%domain%x(this%domain%element(iElem)%node(i)) &
            * QVect
    End Do
  End Subroutine valueJacobianGaussPointPlusQ

  Subroutine computeK(this)
    Implicit none
    Class(poisson1DType), Intent(InOut) :: this
    Integer :: nNodes
    Call this%K%init(nnz = 16*this%domain%nElem, rows = this%domain%nNodes+1)
    Allocate(kVect(this%nGauss))
    Do iElem = 1, this%domain%nElem
       Call valueGauss3(this%kCoef, this%domain%element(iElem)%kCoefIndex, kVect)
       nNodes = this%domain%element(iElem)%nNodes
       Do i = 1, nNodes
          Do j = 1, nNodes 
             Kij = gauss(1.d0/this%domain%element(iElem)%jacobian, kVect &
                  , derivShapeFuncMat(nNodes-1, i, :) &
                  , derivShapeFuncMat(nNodes-1, j, :))
             Call this%K%append(value = Kij &
                  , row = this%domain%element(iElem)%node(i) &
                  , col = this%domain%element(iElem)%node(j))
          End Do
       End Do
    End Do
    Call this%K%getSparse
    Deallocate(kVect)
  End Subroutine computeK

  Subroutine computeRHS(this)
    Implicit none
    Class(Poisson1DType), Intent(InOut) :: this
    Integer :: nNodes
    Allocate(this%rhs(size(this%domain%x)))
    this%rhs = 0
    Allocate(QVect(this%nGauss))
    Do iElem = 1, this%domain%nElem
       nNodes = this%domain%element(iElem)%nNodes
       Call valueGauss3(this%source, this%domain%element(iElem)%sourceIndex, QVect)
       Call this%valueJacobianGaussPointPlusQ
       Do i = 1, this%domain%element(iElem)%nNodes
          fi = gauss(this%domain%element(iElem)%jacobian, QVect &
               , shapeFuncMat(nNodes-1, i, :))
          this%rhs(this%domain%element(iElem)%node(i)) = &
               this%rhs(this%domain%element(iElem)%node(i)) + fi
       End Do
    End Do
  End Subroutine computeRHS

  Subroutine boundaryConditions(this)
    Implicit none
    Class(Poisson1DType), Intent(InOut) :: this
    Integer :: index
    Do i = 1, size(this%DirichletNode)
       index = this%K%AI(this%DirichletNode(i))
       Do while(index < this%K%AI(this%DirichletNode(i)+1))
          this%K%A(index) = 0.d0
          If(this%K%AJ(index) .eq. this%DirichletNode(i)) then
             this%K%A(index) = 1.d0
          End If
          index = index + 1
       End Do
       this%rhs(this%DirichletNode(i)) = this%DirichletValue(i)
    End Do
    Do i = 1, size(this%NeumannNode)
       this%rhs(this%NeumannNode(i)) = &
            this%rhs(this%NeumannNode(i)) &
            - this%NeumannValue(i)
    End Do
  End Subroutine boundaryConditions

  Subroutine computeFlux(this)
    Implicit none
    Class(Poisson1DType), Intent(InOut) :: this
    Real(dp), Dimension(4) :: u
    Real(dp), Dimension(4) :: dN
    Real(dp) :: lastFlux
    Allocate(this%flux(size(this%domain%x)))
    u(1) = -1.d0
    u(4) = 1.d0
    lastFlux = 0.d0
    Do iElem = 1, this%domain%nElem
       u(2) = -1.d0 +  2.d0/(this%domain%element(iElem)%nNodes-1)
       u(3) = -1.d0 + 2*2.d0/(this%domain%element(iElem)%nNodes-1)
       Call this%valueJacobianNodePoints
       Do i = 1, this%domain%element(iElem)%nNodes
          this%flux(this%domain%element(iElem)%node(i)) = 0.d0
          dN = this%domain%element(iElem)%dN(u(i),this%domain%element(iElem)%nNodes)
          Do j = 1, this%domain%element(iElem)%nNodes
             this%flux(this%domain%element(iElem)%node(i)) = &
                  this%flux(this%domain%element(iElem)%node(i)) &
                  + (1.d0/this%domain%element(iElem)%jacobian(i))*dN(j)*this%phi(this%domain%element(iElem)%node(j))
          End Do
          this%flux(this%domain%element(iElem)%node(i)) = &
               this%kCoef(this%domain%element(iElem)%kCoefIndex &
               ,this%domain%x(this%domain%element(iElem)%node(i)))*this%flux(this%domain%element(iElem)%node(i))
       End Do
       this%flux(this%domain%element(iElem)%node(1)) = &
            (this%flux(this%domain%element(iElem)%node(1)) &
            + lastFlux )/2.d0
       lastFlux = this%flux(this%domain%element(iElem)%node(this%domain%element(iElem)%nNodes))
    End Do
    this%flux(this%domain%element(1)%node(1)) = this%flux(this%domain%element(1)%node(1))*2.d0
  End Subroutine computeFlux
  
End Module Poisson1DMod


