Module sparseOperationsMod
  Implicit none
  Public

Contains
!!$ IM 10/24/93-11/23/94
!!$***********************************************************************
!!$  Sinverse1 -- inverse OF SPARSE SYMMETRIC POSITIVE DEFINITE SYSTEM OF
!!$         LINEAR EQUATIONS  Z=inv(M)  GIVEN UT-D-U FACTORIZATION OF M;
!!$
!!$         Replaces a in input matrix ia-ja-a with the corresponding
!!$         inverse elements
!!$
!!$         Compared to Sinverse, this version has smaller memory
!!$         requirements and does not expand ia-ja-a to full storage
!!$***********************************************************************
      SUBROUTINE  fsinverse1&
     (N, P, IP, D, IJU,JU,IU,U, TMPu,tmpz,tmpi,tmpi1&      
     , jja,ia,ja,a)
      implicit none
      INTEGER  P(1),  IP(1), IJU(1), JU(1), IU(1), TMPi1(1)&
           , tmpi(1),jja(1),ia(1),ja(1),n,j1,k1
      real*8 ::  D(1), U(1), a(1), TMPu(1),tmpz(1)

      integer i,j,k,iiu
!!$
!!$  ADDITIONAL PARAMETERS
!!$
!!$    TMPu,tmpz   - real ONE-DIMENSIONAL WORK ARRAYs;  DIMENSION = N
!!$    jja - integer on-dimensional work array of order ia(n+1)-1
!!$    tmpi,tmpi1 - integer one-dimensional work array; dimension=N,
!!$                 tmpi and tmpi1 can occupy the same storage as
!!$                 tmpu and tmpz
!!$
!!$-----------------------------------------------------------------------
      iiu(i,j)=ju(iju(i)-iu(i)+j)
!!$

!!$  CAUTION: U is really -U

!!$----invert in site, z overwrites u
!!$            tmpu keeps unfolded current column of u;
!!$            tmpz keeps unfolded current column of z;
      do i=1,n
         tmpz(i)=0
         tmpu(i)=0
      enddo

      do i=n,1,-1
!!$ dir$ ivdep
         do j=iu(i), iu(i+1)-1
            j1=iiu(i,j)
            tmpu(j1)=u(j)
            tmpz(j1)=u(j)*d(j1)
         enddo

!!$-------off-diagonal elements
         do j=iu(i),iu(i+1)-1
            j1=iiu(i,j)
!!$           tmpz(j1)=tmpz(j1)+tmpu(j1)*d(j1)
!!$ dir$ ivdep
            do k=iu(j1),iu(j1+1)-1
               k1=iiu(j1,k)
               tmpz(j1)=tmpz(j1)+tmpu(k1)*u(k)
               tmpz(k1)=tmpz(k1)+tmpu(j1)*u(k)
            enddo
          enddo

!!$------diagonal element last
!!$ dir$ ivdep
         do j=iu(i),iu(i+1)-1
            d(i)=d(i)+u(j)*tmpz(iiu(i,j))
         enddo

!!$ store inverse and zero all nonzeroes in tmp and tmp1
!!$ dir$ ivdep
         do j=iu(i), iu(i+1)-1
            tmpu(iiu(i,j))=0
            u(j)=tmpz(iiu(i,j))
            tmpz(iiu(i,j))=0
         enddo
       enddo

!!$ replace a in ia-ja-a with inverse elements

      do i=1,n
         tmpi1(i)=i
      enddo
!!$ first partly permute ia-ja-a
      call pperm(n,ip,ia,ja,a,tmpi,jja)
      do i=1,n
         do j=iu(ip(i)),iu(ip(i)+1)-1
            tmpu(p(iiu(ip(i),j)))=u(j)
         enddo
         tmpu(i)=d(ip(i))
         do j=ia(i),ia(i+1)-1
            a(j)=tmpu(ja(j))
         enddo
       enddo

!!$ reverse the permutation
      call pperm(n,tmpi1,ia,ja,a,tmpi,jja)
end SUBROUTINE fsinverse1
!!$ IM - 10-19-1993-11/23/94
!!$*********************************************************************
!!$ Partly permute upper-triangular matrix ia-ja-a using permutation vector
!!$ p.
!!$ The permutation is such that it does not change the indices of elements,
!!$ but insures, that after permutation all elements would be in the
!!$ upper diagonal.
!!$*********************************************************************
        subroutine pperm(n,p,ia,ja,a,tmpia,tmprow)
        implicit none
        integer n,p(1),ia(1),ja(1),tmpia(1),tmprow(1),i,j,k
        real*8 a(1),x

!!$ extra parameters
!!$ tmpia   - integer vector of size n
!!$ tmprow  - integer vector of size ia(n+1)-n

!!$ zero temporary row vector for reorder matrix
        do i=1,n
           tmpia(i)=0
        enddo
!!$ set ja to store column entries and tmprow of row entries
        do i=1,n
           do j=ia(i),ia(i+1)-1
              if (p(i).gt.p(ja(j))) then
                  k=ja(j)
                  ja(j)=i
                  tmprow(j)=k
                 else
                   tmprow(j)=i
                   k=i
                endif
                tmpia(k)=tmpia(k)+1
           enddo
        enddo

!!$ set ia to permuted ia
       do i=1,n
          ia(i+1)=ia(i)+tmpia(i)
          tmpia(i)=ia(i+1)
       enddo

!!$ assign rows to appropriate addresses
        do i=ia(n+1)-1,ia(1),-1
           j=tmprow(i)
           tmpia(j)=tmpia(j)-1
           tmprow(i)=tmpia(j)
        enddo

!!$ final permutation
        do i=1,ia(n+1)-1
           j=tmprow(i)
           if (i.ne.j) then
!!$                swap entries i and j
              k=ja(i)
              ja(i)=ja(j)
              ja(j)=k
              k=tmprow(i)
              tmprow(i)=tmprow(j)
              tmprow(j)=k
              x=a(i)
              a(i)=a(j)
              a(j)=x
              goto 10
           endif
        enddo
end subroutine pperm

!!$AMUB performs the matrix by matrix product C = A * B.
!!$APLSB performs the matrix linear combination C = A+s*B
subroutine amub ( nrow, ncol, job, a, ja, ia, b, jb, ib, c, jc, ic, nzmax, &
  iw, ierr )

!*****************************************************************************80
!
!! AMUB performs the matrix product C = A * B.
!
!  Discussion:
!
!    The column dimension of B is not needed.
!
!  Modified:
!
!    08 January 2004
!
!  Author:
!
!    Youcef Saad
!
!  Parameters:
!
!    Input, integer ( kind = 4 ) NROW, the row dimension of the matrix.
!
!    Input, integer ( kind = 4 ) NCOL, the column dimension of the matrix.
!
!    Input, integer ( kind = 4 ) JOB, job indicator.  When JOB = 0, only the
!    structure is computed, that is, the arrays JC and IC, but the real values
!    are ignored.
!
!    Input, real A(*), integer ( kind = 4 ) JA(*), IA(NROW+1), the matrix in CSR
!    Compressed Sparse Row format.
!
!    Input, b, jb, ib, matrix B in compressed sparse row format.
!
!    Input, integer ( kind = 4 ) NZMAX, the length of the arrays c and jc.
!    The routine will stop if the result matrix C  has a number
!    of elements that exceeds exceeds NZMAX.
!
! on return:
!
! c,
! jc,
! ic    = resulting matrix C in compressed sparse row sparse format.
!
! ierr      = integer ( kind = 4 ). serving as error message.
!         ierr = 0 means normal return,
!         ierr > 0 means that amub stopped while computing the
!         i-th row  of C with i = ierr, because the number
!         of elements in C exceeds nzmax.
!
! work arrays:
!
!  iw      = integer ( kind = 4 ) work array of length equal to the number of
!         columns in A.
!
  implicit none

  integer ( kind = 4 ) ncol
  integer ( kind = 4 ) nrow
  integer ( kind = 4 ) nzmax

  real ( kind = 8 ) a(*)
  real ( kind = 8 ) b(*)
  real ( kind = 8 ) c(nzmax)
  integer ( kind = 4 ) ia(nrow+1)
  integer ( kind = 4 ) ib(ncol+1)
  integer ( kind = 4 ) ic(ncol+1)
  integer ( kind = 4 ) ierr
  integer ( kind = 4 ) ii
  integer ( kind = 4 ) iw(ncol)
  integer ( kind = 4 ) ja(*)
  integer ( kind = 4 ) jb(*)
  integer ( kind = 4 ) jc(nzmax)
  integer ( kind = 4 ) jcol
  integer ( kind = 4 ) jj
  integer ( kind = 4 ) job
  integer ( kind = 4 ) jpos
  integer ( kind = 4 ) k
  integer ( kind = 4 ) ka
  integer ( kind = 4 ) kb
  integer ( kind = 4 ) len
  real ( kind = 8 ) scal
  logical values

  values = ( job /= 0 )
  len = 0
  ic(1) = 1
  ierr = 0
!
!  Initialize IW.
!
  iw(1:ncol) = 0

  do ii = 1, nrow
!
!  Row I.
!
    do ka = ia(ii), ia(ii+1)-1

      if ( values ) then
        scal = a(ka)
      end if

      jj = ja(ka)

      do kb = ib(jj), ib(jj+1)-1

           jcol = jb(kb)
           jpos = iw(jcol)

           if ( jpos == 0 ) then
              len = len + 1
              if ( nzmax < len ) then
                 ierr = ii
                 return
              end if
              jc(len) = jcol
              iw(jcol)= len
              if ( values ) then
                c(len) = scal * b(kb)
              end if
           else
              if ( values ) then
                c(jpos) = c(jpos) + scal * b(kb)
              end if
           end if

         end do

    end do

    do k = ic(ii), len
      iw(jc(k)) = 0
    end do

    ic(ii+1) = len + 1

  end do

  return
end subroutine amub

subroutine aplsb ( nrow, ncol, a, ja, ia, s, b, jb, ib, c, jc, ic, nzmax, &
  iw, ierr )

!*****************************************************************************80
!
!! APLSB performs the matrix linear combination C = A + s * B.
!
!  Modified:
!
!    07 January 2004
!
!  Author:
!
!    Youcef Saad
!
!  Parameters:
!
!    Input, integer ( kind = 4 ) NROW, the row dimension of the matrix.
!
!    Input, integer ( kind = 4 ) NCOL, the column dimension of the matrix B.
!
!    Input, real A(*), integer ( kind = 4 ) JA(*), IA(NROW+1), the matrix in CSR
!    Compressed Sparse Row format.
!
!    Input, real S, scalar factor for B.
!
! b,
! jb,
! ib      =  Matrix B in compressed sparse row format.
!
! nzmax      = integer ( kind = 4 ). The  length of the arrays c and jc.
!         amub will stop if the result matrix C  has a number
!         of elements that exceeds exceeds nzmax. See ierr.
!
! on return:
!
! c,
! jc,
! ic      = resulting matrix C in compressed sparse row sparse format.
!
! ierr      = integer ( kind = 4 ). serving as error message.
!         ierr = 0 means normal return,
!         ierr > 0 means that amub stopped while computing the
!         i-th row  of C with i = ierr, because the number
!         of elements in C exceeds nzmax.
!
! work arrays:
!
! iw      = integer ( kind = 4 ) work array of length equal to the number of
!         columns in A.
!
  implicit none

  integer ( kind = 4 ) ncol
  integer ( kind = 4 ) nrow

  real ( kind = 8 ) a(*)
  real ( kind = 8 ) b(*)
  real ( kind = 8 ) c(*)
  integer ( kind = 4 ) ia(nrow+1)
  integer ( kind = 4 ) ib(nrow+1)
  integer ( kind = 4 ) ic(nrow+1)
  integer ( kind = 4 ) ierr
  integer ( kind = 4 ) ii
  integer ( kind = 4 ) iw(ncol)
  integer ( kind = 4 ) ja(*)
  integer ( kind = 4 ) jb(*)
  integer ( kind = 4 ) jc(*)
  integer ( kind = 4 ) jcol
  integer ( kind = 4 ) jpos
  integer ( kind = 4 ) k
  integer ( kind = 4 ) ka
  integer ( kind = 4 ) kb
  integer ( kind = 4 ) len
  integer ( kind = 4 ) nzmax
  real ( kind = 8 ) s

  ierr = 0
  len = 0
  ic(1) = 1

  iw(1:ncol) = 0

  do ii = 1, nrow
!
!  Row I.
!
     do ka = ia(ii), ia(ii+1)-1

        len = len + 1
        jcol = ja(ka)

        if ( nzmax < len ) then
          ierr = ii
          return
        end if

        jc(len) = jcol
        c(len) = a(ka)
        iw(jcol)= len

     end do

     do kb = ib(ii), ib(ii+1)-1

        jcol = jb(kb)
        jpos = iw(jcol)
        if ( jpos == 0 ) then
           len = len + 1
           if ( nzmax < len ) then
             ierr = ii
             return
           end if
           jc(len) = jcol
           c(len) = s * b(kb)
           iw(jcol)= len
        else
           c(jpos) = c(jpos) + s * b(kb)
        end if

     end do

     do k = ic(ii), len
        iw(jc(k)) = 0
     end do

     ic(ii+1) = len + 1
 
  end do

  return
end subroutine aplsb
end Module sparseOperationsMod
